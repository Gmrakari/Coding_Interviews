

/*
 * Date:2020-07-23 08：38
 * Author:Gmrakari
 * Project:面试题14_调整数组顺序使奇数位于偶数前面
 * 
 */

#题意
题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，
并保证奇数和奇数，偶数和偶数之间的相对位置不变。

样例输入

5 1 2 3 4 5

样例输出

1 3 5 2 4

下面我们考虑算法复杂度的同时还会考虑其稳定性，（排序的稳定型则是指相同元素在数组中的相对位置是否发生变化），这里的稳定性我们理解为，顺序交换后，各个奇数（或者偶数）在数组中的相对位置是否发生变化

#暴力方法

扫描数组，开辟俩个数组，一个存放奇数，另外一个存放偶数。然后再连接数组

#最简单的思路

从头扫描这个数组，每碰到一个偶数时，拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。
挪完之后在数组的末尾有一个空位，这时把该偶数放入这个空位。由于每碰到一个偶数就需要移动O(n)个数字，因此总的时间复杂度是O(n^2)。


void ReorderOddEven(int *pData,unsigned int length)
{
	int *p1,*p2;

	p1 = pData;

	p2 = pData.length - 1;

	while(*p1 % 2 != 0)
	{
		p1++;
	}

	while(*p2 %2 != 1)
	{
		p2--;
	}

	if((*p1 % 2 != 0) && (*p2 % 2 != 1))
	{
		swap(&p1,&p2);
	}

	if()
}

void swap(int *p1,int *p2)
{
	int *temp;

	*temp = *p1;
	*p1 = *p2;
	*p2 = *temp;
}

void ReorderOddEven(int *pData,unsigned int length)
{
	if(pData == NULL || length == 0)
	return ;

	int *pBegin = pData;
	int *pEnd = pData + length - 1;

	while(pBegin < pEnd)
	{

		//向后移动pBegin，直到它指向偶数
		while(pBegin < pEnd && (*pBegin & 0x1) != 0)
			pBegin++;

		//向前移动pEnd,直到它指向奇数
		while(pBegin < pEnd && (*pEnd & 0x1) == 0)
			pEnd--;

		if(pBegin < pEnd)
		{
			int temp = *pBegin;
			*pBegin = *pEnd;
			*pEnd = temp;
		}
	}
}



#如果把题目改成把数组中的数按照大小分为两部分，所有负数都在非负数的前面，该怎么办？
#如果把题目改成把数组中的数分为两部分，能被3整除的数能在不能被3整除的数的前面。怎么办？

#方法

要解决这俩个问题，其实只需要修改函数ReorderOddEven中的两处判断的标准，而大的逻辑框架完全不需要改动。
因此我们可以把这个逻辑框架抽象出来，而把判断的标准变成一个函数指针，也就是用一个单独的函数来判断数字是不是符合标准。
这样我们把整个函数解耦成两部分：
一是判断数字应该在数字前半部分还是后半部分的标准
二是拆分数组的操作

代码如下:


void Reorder(int *pData,unsigned int length,bool (*func)(int))
{
	if(pData == NULL || length == 0)
		return ;

	int *pBegin = pData;
	int *pEnd = pData + length - 1;

	while(pBegin < pEnd)
	{
		//向后移动pBegin，直到它指向fun
		while(pBegin < pEnd && !func(*pBegin))
			pBegin++;

		//向前移动pEnd,直到它指向fun
		while(pBegin < pEnd && func(*pEnd))
			pEnd--;

		if(pBegin < pEnd)
		{
			int temp = *pBegin;
			*pBegin = *pEnd;
			*pEnd = temp;
		}		
	}
}

bool isEven(int n)
{
	return (n & 0x1) == 0;
}

#在上面的代码中，函数Reorder根据func的标准把数组pData分成俩部分；
而函数isEven则是一个具体的标准，即判断一个数是不是偶数。
有了这俩函数，我们可以很方便地把数组中的所有奇数移到偶数的前面。

实现代码如下:

void ReorderOddEven(int *pData,unsigned int length)
{
	Reorder(pData,length,isEven);

}