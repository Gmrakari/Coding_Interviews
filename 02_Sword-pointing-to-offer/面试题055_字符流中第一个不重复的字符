
/*
 * Date:2021-03-17 10:00
 * Author:Gmrakari
 * Project:面试题055_字符流中第一个不重复的字符
 * 
 */

/*
#题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。
当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
如果当前字符流没有存在出现一次的字符，返回#字符。


分析：
	字符只能一个接着一个从字符流中读出来。可以定义一个数据容器来保存字符在字符流中的位置。
当一个字符第一次从字符流中读出来时，把它在字符流中的位置保存到数据容器里。
当这个字符再次从字符流中被读出来时，那么它就不是只出现一次的字符，也就可以被忽略了。
这时把它在数据容器里保存的值更新成一个特殊的值

为了尽可能高效地解决这个问题，需要在O(1)时间内往数据容器里插入一个字符，以及更新一个字符对应的值。
受面试题35的启发，这个数据容器可以用哈希表来实现。
用字符的ASCII码作为哈希表的键值，而把字符对应的位置作为哈希表的值。
*/

class CharStatistics
{
public:
	CharStatistics() : index(0)
	{
		for(int i = 0; i < 256;++i)
			occurrence[i] = -1;
	}

	void Insert(char ch)
	{
		if(occurrence[ch] == -1)
			occurrence[ch] = index;
		else if(occurrence[ch] >= 0)
			occurrence[ch] = -2;

		index++;
	}

	char FirstApperaingOnce()
	{
		char ch = '\0';
		int minIndex = numeric_limits<int>::max();
		for(int i = 0; i < 256;++i)
		{
			if(occurrence[i] >= 0 && occurrence[i] < minIndex)
			{
				ch = (char) i;
				minIndex = occurrence[i];
			}
		}

		return ch;
	}
private:
	//occurrence[i] : A character with ASCII value i;
	//occurrence[i] = -1:The character has not found;
	//occurrence[i] = -2:The character has been found for mutlple times
	//occurrence[i] >= 0:The character has been found only once
	int occurrence[256];
	int index;
};

/*
 * 哈希表用数组occurrence实现。
 * 数组中的元素occurrence[i]和ASCII码的值为i的字符相对应。
 * 最开始的时候数组中的所有元素都初始化为-1
 * 当一个ASCII码为i的字符第一次从字符流中读出时,occurrence[i]的值更新为它在字符流中的位置
 * 当这个字符再次从字符流读出时(occurrence[i] >= 0),occurrence[i]的值更新为-2
 *
 * 当我们需要找出到目前为止从字符流里读出的所有字符中第一个不重复的字符时，我们只需要扫描整个数组，
 * 并从中找出最小的 >= 0 的值对应的字符
 */