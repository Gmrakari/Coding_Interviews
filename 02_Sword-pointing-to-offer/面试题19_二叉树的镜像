


/*
 * Date:2020-08-18 10：10
 * Author:Gmrakari
 * Project:面试题19_二叉树的镜像
 * 
 */

struct BinaryTreeNode
{
	int m_nValue;
	BinaryTreeNode* m_pLeft;
	BinaryTreeNode* m_pRight;
};

void MirrorRecursively(BinaryTreeNode* pNode)
{
	if(pNode == NULL)
		return ;
	if(pNode->m_pLeft == NULL && pNode->m_pRight == NULL)
		return ;

	BinaryTreeNode* pTemp = pNode->m_pLeft;
	pNode->m_pLeft = pNode->m_pRight;
	pNode->m_pRight = pTemp;

	if(pNode->m_pLeft)
		MirrorRecursively(pNode->m_pLeft);

	if(pNode->m_pRight)
		MirrorRecursively(pNode->m_pRight);
}


#include <iostream>
#include <stack>
#include <algorithm>
using namespace std;

//  调试开关
#define __tmain main

#ifdef __tmain

#define debug cout

#else

#define debug 0 && cout

#endif // __tmain

#ifdef __tmain
struct TreeNode
{
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL)
    {
	}
};
#endif // __tmain

class Solution
{
	public:
		void MirrorPre(TreeNode *root)
		{
			if(root == NULL)
				return ;

			stack<TreeNode *> nstack;
			TreeNode *node = root;
	
			while(node != NULL || nstack.empty() != NULL)
			{
				while(node != NULL)
				{
					if(node->left != NULL || node->right != NULL)
					{
						swap(node->left,node->right);
					}

					nstack.push(node);
					node = node->left;
				}
				if(nstack.empty() != true)
				{
					node = nstack.top();
					nstack.pop();
					node = node->right;
				}
			}
		}
		void MirrorPreBFS(TreeNode *root)
		{
			if(root == NULL)
			return ;

			stack<TreeNode *> nstack;

			nstack.push(root);

			TreeNode *node = root;
			while(nstack.empty() != true)
			{
				node = nstack.top();
				nstack.pop();

				if(node->left != NULL || node->right != NULL)
				{
					swap(node->left,node->right);
				}

				if(node->left != NULL)
				{
					nstack.push(node->left);
				}

				if(node->right != NULL)	
				{
					nstack.push(node->right);
				}

			}
		}		
};

int __tmain( )
{
    debug <<"test" <<endl;
    return 0;
}