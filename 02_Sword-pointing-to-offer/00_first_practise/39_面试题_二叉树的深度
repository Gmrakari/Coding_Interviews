
/*
 * Date:2021-02-26 10:15
 * Author:Gmrakari
 * Project:面试题039_二叉树的深度
 */

#题意
题目描述

输入一棵二叉树，求该树的深度。

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

struct BinaryTreeNode
{
	int				m_nValue;
	BinaryTreeNode* m_pLeft;
	BinaryTreeNode* m_pRight;
};

int TreeDepth(BinaryTreeNode* pRoot)
{
	if(pRoot == NULL)
		return 0;

	int nLeft = TreeDepth(pRoot->m_pLeft);
	int nRight = TreeDepth(pRoot->m_pRight);

	return (nLeft > nRight) ? ( nLeft + 1 ) : ( nRight + 1 ); 
}

题目二：
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

思路：
在遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义它就是一棵平衡二叉树

bool IsBalanced(BinaryTreeNode* pRoot)
{
	is(pRoot == NULL)
	return true;

	int left = TreeDepth(pRoot->m_pLeft);
	int nRight = TreeDepth(pRoot->m_pRight);
	int diff = left - rigth;

	if(diff > 1 || diff < -1)
		return false;

	return IsBalanced(pRoot->m_pLeft) && IsBalanced(pRoot->m_pRight);
}

bool IsBalanced_2(BinaryTreeNode* pRoot,int* pDepth)
{
	if(pRoot == NULL)
	{
		*pDepth = 0;
		return true;
	}
	int left,right;
	if(IsBalanced_2(pRoot->m_pLeft,&left)
		&& IsBalanced_2(pRoot->m_pRight,&right))
	{
		int diff = left - right;
		if(diff <= 1 && diff >= 1)
		{
			*pDepth = 1 + (left > right ? left : right);
			return true; 
		}
	}
	return false;
}