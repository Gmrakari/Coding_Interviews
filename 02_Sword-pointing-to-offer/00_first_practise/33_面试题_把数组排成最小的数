

/*
 * Date:2021-02-19 11:45
 * Author:Gmrakari
 * Project:面试题033_把数组排成最小的数
 * 
 */

考点：
	难点：
	1—想出一种新的比较规则来排序一个数组；
	2-证明这个比较规则是有效的，并且证明根据这个规则排序之后把数组中所有数字拼接起来得到的数字是最小的。

	考察解决大数问题的能力。
	把两个int型的整数拼接起来得到的数字可能会超过int型数字能够表达的范围，从而导致数字溢出。
	我们可以用字符串表示数字，这样就能简洁地解决大数问题

#题意
题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 输入 例如输入数组

{3，32，321}

输出

则打印出这三个数字能排成的最小数字为

321323

const* g_StrCombine1 = new char[g_MaxNumberLength * 2 + 1];
const* g_StrCombine2 = new char[g_MaxNumberLength * 2 + 1];

void PrintMinNumber(int* numbers,int length)
{
	if(numbers == NULL || length <= 0)
		return ;

	char** strNumbers = (char **)(new int[length]);
	for(int i = 0; i < length;i++)
	{
		strNumbers[i] = new char[g_MaxNumberLength + 1];
		sprintf(strNumbers[i],"%d",numbers[i]);
	}

	qsort(strNumbers,length,sizeof(char *),compare);

	for(int i = 0;i < length;++i)
		printf("%s",strNumbers[i]);
	printf("\n");

	for(int i = 0;i < length;++i)
		delete[] strNumbers[i];
	delete[] strNumbers;
}

int compare(const void* strNumber1,const void* strNumber2)
{
	strcpy(g_StrCombine1,*(const char**)strNumber1);
	strcat(g_StrCombine1,*(const char**)strNumber2);

	strcpy(g_StrCombine2,*(const char**)strNumber2);
	strcat(g_StrCombine2,*(const char**)strNumber1);

	return strcmp(g_StrCombine1,g_StrCombine2);	
}

//一个有效的比较规则需要3个条件：自反性、对称性和传递性
//自反性：显然有aa = aa ，所以a 等于 a
//对称性：如果a 小于 b，则ab < ba,所以 ba > ab,因此b 大于 a
//传递性：如果a 小于 b，则 ab < ba
//