

/*
 * Date:2020-07-14 10：00
 * Author:Gmrakari
 * Project:面试题9_斐波那契数列
 * 
 */


如果我们需要重复地多次计算相同地问题，通常可以选择用递归或者循环两种不同地方法

如求1 + 2 + 3 + ··· + n,我们可以用递归或者循环两种方式求出结果

int AddForm1ToN_Recursive(int n)
{
	return n <= 0 ? 0 : n + AddForm1ToN_Recursive(n - 1);
}

int AddForm1ToN_Iterative(int n)
{
	int result = 0;
	for(int i = 1;i <= n; i++)
	{
		result += i;
	}
	return result;
}

/*
 * update:2020-07-16 07:22
 * 
 */

//递归不仅会影响程序地效率，还有一个问题：调用栈溢出。需要为每一次函数用地内存栈中分配空间，而每个进程的栈容量是有限的。当递归调用的层级太多时，就会超出栈的容量，从而导致调用栈溢出。

#题目 写一个函数，输入n，求斐波那契(Fibonacci)而数列的第n项。
斐波那契数列的定义如下

        	/        0       	n = 0               
f(n) =     -         1			n = 1
        	\  f(n-1)+f(n+1)    n > 2

long long Fibonacci_1(unsigned int n)
{
	if(n <= 0)
		return 0;

	if(n == 1)
		return 1;

	return Fibonacci(n - 1) + Fibonacci(n - 2);
}


时间复杂度O(n)的实现方法

long long Fibonacci_2(unsigned int n)
{
	int result[2] = {0 , 1};
	if(n < 2)
		return result[n];

	long long fibNMinusOne = 1;
	long long fibNMinusTwo = 0;
	long long fibN = 0;

	for(unsigned int i = 2; i <= n;++i)
	{
		fibN = fibNMinusOne + fibNMinusTwo;

		fibNMinusTwo = fibNMinusOne;

		fibNMinusOne = fibN;
	}
	return fibN;
}         

第一种基于递归的解法虽然直观但时间效率低，在实际软件开发中不会用这种方法
第二种方法把递归的算法用循环实现，极大地提高了时间效率


