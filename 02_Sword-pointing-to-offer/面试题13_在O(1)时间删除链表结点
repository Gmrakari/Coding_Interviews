

/*
 * Date:2020-07-23 08：13
 * Author:Gmrakari
 * Project:面试题13_在O(1)时间删除链表结点
 * 
 */

#题目
给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。

struct ListNode
{
	int m_nValue;
	ListNode* m_pNext;
};

void DeleteNode(ListNode** pListHead,ListNode* pToBeDeleted)
{
	if(*pListHead && pToBeDeleted)
		return ;

	 pToBeDeleted->m_nValue = pToBeDeleted->m_pNext->m_nValue;
	 pToBeDeleted->m_pNext = pToBeDeleted->m_pNext->m_pNext;
	 pToBeDeleted->m_pNext->m_pNext = NULL;
}


void DeleteNode(ListNode** pListHead,ListNode* pToBeDeleted)
{
	if(!pListHead || !pToBeDeleted)
		return ;

	//要删除的结点不是尾节点
	if(pToBeDeleted->m_pNext != NULL)
	{
		ListNode* pNext = pToBeDeleted->m_pNext;
		pToBeDeleted->m_nValue = pNext->m_nValue;
		pToBeDeleted->m_pNext = pNext->m_pNext;
		
		delete pNext;
		pNext = NULL;
	}

	//链表只有一个结点，删除头结点（也是尾节点）
	else if(*pListHead == pToBeDeleted)
	{
		delete pToBeDeleted;
		pToBeDeleted = NULL;
		*pListHead = NULL;
	}

	//链表中有多个结点，删除尾节点
	else
	{
		ListNode* pNode = *pListHead;
		while(pNode->m_pNext != pToBeDeleted)
		{
			pNode = pNode->m_pNext;
		}

		pNode->m_pNext = NULL;
		delete pToBeDeleted;
		pToBeDeleted = NULL;
	}
}

#分析这种思路的时间复杂度

对于n-1个非尾结点而言，我们可以在O(1)时把下一个结点的内存复制覆盖要删除的结点，并删除下一个结点；
对于尾结点而言，由于仍然需要顺序查找，时间复杂度时是O(n)。
总的平均时间复杂度是[(n - 1)*O(1) + O(n)]/n，结果还是O(1)。


