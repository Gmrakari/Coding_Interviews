


/*
 * Date:2020-07-27 07：15
 * Author:Gmrakari
 * Project:面试题15_链表中倒数第k个结点
 * 
 */

#题意
题目描述

输入一个链表，输出该链表中倒数第k个结点。

链表结点定义如下

struct ListNode
{
	int m_nValue;
	ListNode* m_pNext;
};

思路 
定义两个指针 p1 和 p2

p1 走k-1步 p2 开始走
p1 和 p2 一起走,p1走完 p2就是倒数第k个结点

ListNode* FindKthToTail(ListNode* pListHead,unsigned int k)
{
	ListNode *pAhead = pListHead;
	ListNode *pBehind = NULL;

	for(unsigned int i = 0;i < k - 1;++i)
	{
		pAhead = pAhead->m_pNext;
	}

	pBehind = pListHead;

	while(pAhead->m_pNext ！= NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
	}
	return pBehind;
}

三种办法让这段代码崩溃

1_输入的pListHead为空指针。由于代码会试图访问空指针指向的内存，程序崩溃。

2_输入的以pListHead为头结点的链表的结点总数少于k。由于在for循环中会在链表上向前走k-1步，仍然会由于空指针造成程序崩溃

3_输入的参数k为0。由于k是一个无符号整数，那么在for循环中k-1得到将不是-1，而是4294967295(无符号的0xFFFFFFFF)。

ListNode* FindKthToTail(ListNode* pListHead,unsigned int k)
{

	if(pListHead == NULL || k == 0 )
		return;

	ListNode *pAhead = pListHead;
	ListNode *pBehind = NULL;

	for(unsigned int i = 0;i < k - 1;++i)
	{
		if(pAhead->m_pNext != NULL)
			pAhead = pAhead->m_pNext;
		else
			return NULL;
	}

	pBehind = pListHead;

	while(pAhead->m_pNext ！= NULL)
	{
		pAhead = pAhead->m_pNext;
		pBehind = pBehind->m_pNext;
	}
	return pBehind;
}
