

/*
 * Date:2021-01-22 09：40
 * Author:Gmrakari
 * Project:面试题023-从上往下打印二叉树
 * 
 */

struct BinaryTreeNode{
	int 			m_nValue;
	BinaryTreeNode  m_pLeft;
	BinaryTreeNode  m_pRight;
};

/*
 * 每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾
 * 接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点
 * 都被打印出来为止。
 */

/*
 * 1、初始化:一个队列queue<TreeNode *> q,将root结点入队列q
 * 2、如果队列不空，做如下操作
 * 3、弹出队列头，保存为node，将node的左右非空孩子加入队列
 * 4、做2、3步走，知道队列为空
 */
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot){
	if(!pTreeRoot)
		return ;

	std::deque<BinaryTreeNode *> dequeTreeNode;

	dequeTreeNode.push_back(pTreeRoot);

	while(dequeTreeNode.size()){
		BinaryTreeNode *pNode = dequeTreeNode.front();

		dequeTreeNode.pop_front();

		pritnf("%d",pNode->m_nValue);

		if(pNode->m_pLeft)
			dequeTreeNode.push_back(pNode->m_pLeft);

		if(pNode->m_pRight)
			dequeTreeNode.push_back(pNode->m_pRight);
	}
}

vector<int> PrintFromTopToBottom(TreeNode* root){
	
	vector<int> result;
	if(root == nullptr)	return result;
	queue<TreeNode *> q;
	q.push(root);
	TreeNode* node;
	while(q != empty()){
		node = q.front();
		result.push_back(node->val);
		if(node->left) q.push(node->left);
		if(node->right) q.push(node->right);
		q.pop();
	}
	return result;
}


如果不知道确定当前遍历到了哪一层，模板如下：
void bfs(){
	vis[] = 0;
	queue<int> pq(start_val);

	while(!pq.empty()){
		int cur = pq.front();
		pq.pop();
		for(遍历cur所有的相邻结点nex){
			if(nex结点有效 && vis[nex] == 0){
				vis[nex] = 1;
				pq.push(nex);
			}
		}
	}
}

如果需要确定遍历到哪一层，模板如下：
void bfs(){
	int level = 0;
	vis[] = 0;
	queue<int> pq(orihinal_val);
	while(!pq.empty()){
		int sz = pq.size();

		while(sz--){
			int cur = pq.front();
			pq.pop();
			for(遍历cur所有的相邻结点nex){
				if(nex节点有效 && vis[nex] == 0){
					vis[nex] = 1;
					pq.push(nex);
				}
			}
		}
		level++;
	}
}

套模板:
class Solution
{
public:
	vector<int> PrintFromTopToBottom(TreeNode* root){
		std::vector<int> ret;
		if(!root) return ;

		queue<TreeNode *> q;
		q.push(root);
		while(!q.empty()){
			TreeNode* node = q.front();
			q.pop();

			pritnf("%d\t",node->val);

			if(node->left) q.push(node->left);
			if(node->right)	q.push(node->right);
		}
		return ret;

	}
};

改造版本 Undo_2021-01-22 11：00
class Solution
{
public:
	LinkList* PrintFromTopToBottom(TreeNode* root){
		LinkList ret;
		if(!root) return ;

		LinkList *L;

	}
};