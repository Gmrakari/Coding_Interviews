

/*
 * Date:2021-03-16 08:29
 * Author:Gmrakari
 * Project:面试题053_正则表达式匹配
 * 
 */

#题意
题目描述

请实现一个函数用来匹配包括'.'和''的正则表达式。模式中的字符'.'表示任意一个字符，而''表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"abaca"匹配，但是与"aa.a"和"ab*a"均不匹配

样例输入

"a","ab*a"

样例输出

false

#分治–类似与深度优先搜索DFS

bool match(char* str,char* pattern)
{
	if(str == NULL || pattern == NULL)
		return false;

	return matchCore(str,pattern);
}

bool matchCore(char* str,char* pattern)
{
	if(*str == '\0' && *pattern == '\0')
		return true;

	if(*str != '\0' && *pattern == '\0')
		return false;

	if(*(pattern + 1) == '*')
	{
		if(*pattern == *str || (*pattern == '.' && *str != '\0'))
			//moce on the next state
			return matchCore(str + 1,pattern + 2)
			//stay on the currrent state
			|| matchCore(str + 1,pattern)
			//ignore a '*'
			|| match(str,pattern + 2);
		else
		{
			//ignore a '*'
			return matchCore(str,pattern + 2);
		}
	}
	if(*str == *pattern || (*pattern == '.' && *str != '\0'))
		return matchCore(str + 1,pattern + 1);

	return false;
}

github:

分治搜索的方法

考虑特殊情况即s字符串或者p字符串结束
	1、s字符串结束，要求p也结束或者间隔(例如p = "ab*c ...")，否则无法匹配
	2、s字符串未结束，而p字符串结束，则无法匹配

s字符串与p字符串均未结束
	1、(p + 1)字符不为'',则只需比较s字符与p字符，若相等则递归到(s + 1)字符串与(p + 1)字符串的比较，否则无法匹配
	2、(p + 1)字符不为'',则p字符可以匹配s字符串中从0开始任意多(记为i)等于p的字符，然后递归到(s + i + 1)字符串与*(p + 2)字符串的比较，否则无法匹配

//if p[j + 1] == '*' -> (i + 1,j + 1)
//else if p[i] == p[j] ->(i + 1,j + 2) or (i,j + 2)
//else -> (i,j + 2)

class Solution
{
public:
	bool match(const char *s,const char *p)
	{
		if(*p == '\0')						//正则p到底末尾时
		{
			return !(*s);					//如果串s页到达末尾，则匹配成功
		}

		int slen = strlen(s),plen = strlen(p);

		if(plen == 1 || *(p + 1) != '*')	//如果正则串只有一个长度 如果 匹配*
		{
			return slen && (p[0] == '.' || *s == *p) && match(s + 1,p + 1);
		}
		else
		{
			//匹配一个字符
			while(*s != '\0' && (*p == '.' || *s == *p))
			{
				if(match(s++,p + 2))
				{
					return true;
				}
			}
		}

		//匹配0个字符
		return match(s,p + 2);
	}
};


	