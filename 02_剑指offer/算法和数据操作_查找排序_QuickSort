

/*
 * Date:2020-07-10 08：38
 * Author:Gmrakari
 * Project:算法和数据操作_查找排序
 * 
 */

重点掌握二分排序、归并查找、快速排序

算法基本可以用递归和循环两种不同的方式实现。递归的实现方法代码会比较简洁，但性能不如基于循环的实现方法

位运算可以看成一类特殊的算法

它时把数字表示成二进制之后对0和1的操作。只有与(&)、或(|)、异或(^)、左移(<<)、右移(>>)5种位运算

查找 排序

顺序查找、二分查找、哈希查找和二叉排序树查找

#如果面试时要求在排序的数组（或者部分排序的数组）中查找一个数字或者统级某个数字出现的次数，可以尝试用二分查找算法

哈希表和二叉排序树查找的重点在于考察对应的数据结构，哈希表最主要的优点是我们利用它能够在O（1）时间查找某一元素，是效率最高的查找方式
其缺点是需要额外的空间来实现哈希表。

排序

要求：比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。

对各种排序算法的特点烂熟于胸，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点

实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组的左边，比选择的数字大的数字移到数组的右边。

int Partition(int data[],int length,int start,int end)
{
	start = data[0];
	end = data[length - 1];

	if(data == NULL || length <= 0 || start < 0 || end >= length)
		throw new std::exception("Invalid exception");

	int index = RandomInRange(start,end);

	Swap(&data[index],&data[end]);

	int small = start - 1;
	for(index = start;index < end;++ index)
	{
		if(data[index] < data[end])
		{
			++small;
			if(small != index)
				Swap(&data[index],&data[small]);
		}
	}
	++small;
	Swap(&data[small],&data[end]);

	return small;
}

函数RandomInRange用来生成一个在start和end之间的随机数，函数Swap的作用是用来交换两个数字


使用递归的思路分别对每次选中的数字的左右两边排序
void QuickSort(int data[],int length,int start,int end)
{
	if(start == end)
		return ;

	int index= Partition(data,length,start,end);
	if(index > start)
		QuickSort(data,length,start,index -1 );
	if(index < end)
		QuickSort(data,length,index + 1,end);
}


快速排序虽然总体平均效率最好，但也不是任何时候都是最优的算法。
比如数组本身已经排好序了，而每一轮排序的时候都是以最后一个数字作为比较的标准，此时快速排序的效率只有O(n^2)。
应聘者一定要问清楚这个排序应用的环境是什么、有那些约束条件，在得到足够多的信息之后再选择最合适的排序算法

A&Q 

A:请实现一个排序算法，要求时间效率O(n)

Q:对什么数字进行排序，有多少个数字？

A:我们想对公司所有员工的年龄排序。我们公司总共有几万名员工

Q:也就是说数字的大小是在一个较小的范围之内的，对吧？

A:嗯，是的。

Q:可以使用辅助空间吗

A:看你用多少辅助内存。只允许使用常量大小辅助空间，不得超过O(n)。

void SortAges(int ages[],int length)
{
	if(age == NULL || length <= 0)
		return ;

	const int oldestAge = 99;
	int timesOfAge[oldestAge + 1];

	for(int i = 0;i <= oldestAge;i++)
		timesOfAge[i] = 0; //统计每个年龄出现的次数

	for(i = 0;i < length;++i)
	{
		int age = age[i];
		if(age < 0 || age > oldestAge)
			throw new std::exception("age out of range");

		++ timesOfAge[age];
	}

	int index = 0;
	for(int i = 0;i <= oldestAge; ++ i)
	{
		for(int j = 0;j < timesOfAge[i];++ j)
		{
			ages[index] = i;
			++ index;
		}
	}
}

//以上用长度100的整数数组作为辅助空间换来了O(n)的时间效率