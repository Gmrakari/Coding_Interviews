
/*
 * Date:2021-03-04 15:57
 * Author:Gmrakari
 * Project:面试题044_扑克牌的顺子
 */

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...

他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票 ,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”, “Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。

LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。

样例输入

3 5 1 0 4

3 5 4 7 6

3 5 7 4 8

样例输出

So Lucky!

So Lucky!

Oh My God!

方法：把数组排序

由于0可以当成任意数字，我们可以用0去补满数组中的空缺。

如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的0可以补满这两个数字的空缺，这个数组实际上还是连续的

我们需要做3件事情：首先把数组排序，再统计数组中的0的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。
如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的；反之则不连续

如果数组中的非0数字重复出现，则该数组不是连续的。
换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子


#include <iostream>
#include <cstdlib>
using namespace std;

bool IsContinuous(int* numbers,int length)
{

	int compare(const void *arg1,const void *arg2);
	if(numbers == NULL || length < 1)
		return false;

	qsort(numbers,length,sizeof(int),compare);

	int numberOfZero = 0;
	int numberofGap = 0;

	for(int i = 0; i < length && numbers[i] == 0;++i)
	{
		++numberOfZero;
	}

	//count the gap
	int small = numberOfZero;
	int big = small + 1;
	while(big < length)
	{
		//two numbers equal,it is not a continuous array
		if(numbers[small] == numbers[big])
			return false;

		numberofGap += numbers[big] - numbers[small] - 1;
		small = big;
		++big;
	}
	return (numberofGap > numberOfZero) ? false : true;
}

int compare(const void *arg1,const void *arg2)
{
	return *(int*)arg1 - *(int*)arg2;
}


int main(int argc,const char* argv[])
{

	bool IsContinuous(int* numbers,int length);
	int number[] = {3,5,1,0,4};
	int number1[] = {3,5,7,4,8};
	int len = sizeof(number) / sizeof(*number);

	cout <<	IsContinuous(number,len) << endl;
	cout <<	IsContinuous(number1,len) << endl;
}


阿秀牛客解法

1、排序

2、计算所有相邻数字间隔总数

3、计算0的个数

4、如果 2 == 3 || 3 > 2 就是顺子

5、如果出现对子，则不是顺子

bool IsContinuous(vector<int> numbers)
{
	int len = numbers.size();
	if( len < 5) return false;
	sort(numbers.begin(),numbers.end());
	int numofZero = 0,numOfInner = 0;
	for(int i = 0; i < len;++i)
	{
		if(numbers[i] == 0) ++numofZero;
		else if(numbers[i] == numbers[i + 1])
			return false;
		else
			numOfInner += numbers[i + 1] - numbers[i] - 1;
	}
	if(numofZero > numOfInner) return true;
	return false;
}