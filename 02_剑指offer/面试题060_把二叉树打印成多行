

/*
 * Date:2021-03-31 10:09
 * Author:Gmrakari
 * Project:面试题060_把二叉树打印成多行
 * 
 */

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。


#分析
其实就是层次遍历，这个我们在我之前的一篇博客里面将的很清楚了

二叉树的遍历详解（前序中序后序层次-递归和非递归）

剑指Offer--023-从上往下打印二叉树（层次遍历二叉树）

其中调试的时候使用了

剑指Offer--006-重构二叉树来辅助我们通过前序和中序遍历的序列来生成二叉树

直接贴代码，只需要直接将我们层次遍历输出过程，变成将输入压入vector中即可


void print(BinaryTreeNode* pRoot)
{
	if(pRoot == NULL)
		return ;

	std::queue<BinaryTreeNode *> nodes;
	nodes.push(pRoot);
	int nextLevel = 0;
	int toBePrinted = 1;
	while(!nodes.empty())
	{
		BinaryTreeNode* pNode = nodes.front();
		printf("%d",pNode->m_nValue);

		if(pNode->m_pLeft != NULL)
		{
			nodes.push(pNode->m_pLeft);
			++nextLevel;
		}

		if(pNode->m_pRight != NULL)
		{
			nodes.push(pNode->m_pRight);
			++nextLevel;
		}
		nodes.pop();
		--toBePrinted;
		if(toBePrinted == 0)
		{
			printf("\n");
			toBePrinted = nextLevel;
			nextLevel = 0;
		}
	}
}

上述代码中,变量toBePrinted表示在当前层中还没有打印的结点数，而变量nextLevel表示下一层的结点数。
如果一个结点有子结点，我们每把一个子结点加到队列中，同时把变量nextLevel加1.每当我们打印一个结点,toBePrinted - 1
当toBePrinted变成0时，表示当前层所有结点已经打印完了，可以继续打印下一层