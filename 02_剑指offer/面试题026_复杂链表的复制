/*
 * Date:2021-02-04 11:00
 * Author:Gmrakari
 * Project:面试题026：复杂链表的复制
 * 
 */

题意
题目描述

请实现函数ComplexListNode* Clone(ComplexListNode* pHead),复制一个复杂链表。
在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL。

struct ComplexListNode
{
	int				 m_nValue;
	ComplexListNode* m_pNext;
	ComplexListNode* m_pSibling;	
};

//复制原始链表的任一节点N并创建新节点N'，再把N'链接到N的后边
void CloneNodes(ComplexListNode* pHead){
	ComplexListNode* pNode = pHead;
	while(pNode != NULL){
		ComplexListNode* pCloned = new ComplexListNode();
		pCloned->m_nValue = pNode->m_nValue;
		pCloned->m_pNext = pNode->m_pNext;
		pCloned->m_pSibling = NULL;

		pNode->m_pNext = pCloned;
		pNode = pCloned->m_pNext;
	}
}

//如果原始链表上的节点N的pNode指向S，则对应的复制节点N'的pNode指向S的下一个节点S'
void ConnectSiblingNodes(ComplexListNode* pHead){
	ComplexListNode* pNode = pHead;
	while(pNode != NULL){
		ComplexListNode* pCloned = pNode->m_pNext;
		if(pNode->m_pSibling != NULL){
			pCloned->m_pSibling = pNode->m_pSibling->m_pNext;
		}
		pNode = pCloned->m_pNext;
	}
}

//把得到的链表拆成两个链表，奇数位置上的结点组成原始链表，偶数位置上的结点组成复制出来的链表
ComplexListNode* ReconnectNodes(ComplexListNode* pHead){
	ComplexListNode* pNode = pHead;
	ComplexListNode* pClonedHead = NULL;
	ComplexListNode* pClonedNode = NULL;

	//初始化
	if(pNode != NULL){
		pClonedHead = pClonedHead = pNode->m_pNext;
		pNode->m_pNext = pClonedNode->m_pNext;
		pNode = pNode->m_pNext;
	}

	//循环
	while(pNode != NULL){
		pClonedNode->m_pNext = pNode->m_pNext;
		pClonedNode = pClonedNode->m_pNext;
		pNode->m_pNext = pClonedNode->m_pNext;
		pNode = pNode->m_pNext;
	}
	return pClonedHead;
}

//三步合一
ComplexListNode* Clone(ComplexListNode* pHead){
	CloneNodes(pHead);
	ConnectSiblingNodes(pHead);
	ReconnectNodes(pHead);
}