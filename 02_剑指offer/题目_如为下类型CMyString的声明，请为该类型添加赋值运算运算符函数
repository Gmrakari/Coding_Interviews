
/**
*
*题目:如为下类型CMyString的声明，请为该类型添加赋值运算运算符函数
*/

class CMyString{
	public:
		CMyString(char* pData = NULL);
		CMyString(const CMyString& str);
		~CMyString(void);
	private:
		char* m_pData;
};

/*
*
1、是否把返回值的类型说明为该类型的引用，并在函数结束前返回实例自身的引用(即*this)

2、是否把传入的参数的类型声明为常量引用

3、是否释放实例自身已有的内存

4、是否判断传入的参数和当前的实例(*this)是不是同一个实例
*/



CMyString& CMyString::operator = (const CMyString &str){
	if(this == &str) return *this;

	delete []m_pData;
	m_pData = NULL;
	m_pData = new char[strlen(str.m_pData) + 1];
	strcpy(m_pData,str.m_pData);

	return *this;
}


CMyString& CMyString::operator  =(const CMyString &str){
	if(this != &str){
		CMyString strTemp(str);

		char* pTemp = strTemp.m_pData;
		strTemp.m_pData = m_pData;
		m_pData = pTemp;
	}
	return *this;
}