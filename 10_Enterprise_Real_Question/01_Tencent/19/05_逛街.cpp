

/*
 * Date:2021-06-25 08:36
 * filename:05_guangjie.cpp
 *
 */

/*


	小 Q 在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很
多高楼，共有 n 座高楼排成一行。
	小 Q 从第一栋一直走到了最后一栋，小 Q 从来都没有见到这么多的
楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼
的高度大于等于后面的楼时，后面的楼将被挡住）

输入描述:
输入第一行将包含一个数字 n，代表楼的栋数，接下来的一行将包含
n 个数字 wi(1<=i<=n)，代表每一栋楼的高度。

1<=n<=100000;
1<=wi<=100000;

输出描述:
输出一行，包含空格分割的 n 个数字 vi，分别代表小 Q 在第 i 栋楼时
能看到的楼的数量。

输入例子 1:
6
5 3 8 3 2 5

6栋楼,第一栋5,第二栋3,第三栋8,第四栋3,第五栋2,第六栋5

输出例子 1:
3 3 5 4 4 4

当小q在第3时候，向前能看到2,1;向后能看到4,6,加上3 就是1,2,3,4,6


例子说明 1:
当小 Q 处于位置 3 时，他可以向前看到位置 2,1 处的楼，向后看到位
置 4,6 处的楼，加上第 3 栋楼，共可看到 5 栋楼。当小 Q 处于位置 4 时，
他可以向前看到位置 3 处的楼，向后看到位置 5,6 处的楼，加上第 4 栋
楼，共可看到 4 栋楼。

*/

/*
 * 题解
 * 单调栈
 * 开辟一个数组,保留往右看得到得数量,从右往左遍历,利用单调栈将看到
 * 得数量保留在数组中，再从左边往右遍历,获取往左看的计数
 */

#include <bits/stdc++.h>
using namespace std;
int n,a[100005],ans[100005];
int main() {
	ios::sync_with_stdio(false), cin.tie(0),cout.tie(0);
	stack<int> s;
	cin >> n;
	for (int i = 1;i <= n;i++) cin >> a[i];
	memset(ans, 0, sizeof ans);
	for (int i = 1;i <= n;i++) {
		ans[i] += s.size();
		while (!s.empty() && s.top() <= a[i]) {
			s.pop();
		}
		s.push(a[i]);
	}
	while (!s.empty()) s.pop();
	for (int i = n; i >= 1;i--) {
		ans[i] += s.size();
		while (!s.empty() && s.top() <= a[i]) s.pop();
		s.push(a[i]);
	}
	for (int i = 1;i <= n;i++) cout << ans[i] + 1 << "\n"[i == n];
	return 0;
}
